//! Initialize the user stack for the application
//!
//! The structure of the user stack is described in the following figure:
//! position            content                     size (bytes) + comment
//!   ------------------------------------------------------------------------
//! stack pointer ->  [ argc = number of args ]     8
//!                   [ argv[0] (pointer) ]         8   (program name)
//!                   [ argv[1] (pointer) ]         8
//!                   [ argv[..] (pointer) ]        8 * x
//!                   [ argv[n - 1] (pointer) ]     8
//!                   [ argv[n] (pointer) ]         8   (= NULL)
//!                   [ envp[0] (pointer) ]         8
//!                   [ envp[1] (pointer) ]         8
//!                   [ envp[..] (pointer) ]        8
//!                   [ envp[term] (pointer) ]      8   (= NULL)
//!                   [ auxv[0] (Elf32_auxv_t) ]    16
//!                   [ auxv[1] (Elf32_auxv_t) ]    16
//!                   [ auxv[..] (Elf32_auxv_t) ]   16
//!                   [ auxv[term] (Elf32_auxv_t) ] 16  (= AT_NULL vector)
//!                   [ padding ]                   0 - 16
//!                   [ argument ASCIIZ strings ]   >= 0
//!                   [ environment ASCIIZ str. ]   >= 0
//!
//! (0xbffffff8)      [ end marker ]                8   (= NULL)
//!
//! (0xc0000000)      < bottom of stack >           0   (virtual)
//!
//! More details can be found in the link: <https://articles.manugarg.com/aboutelfauxiliaryvectors.html>

extern crate alloc;

use alloc::{collections::BTreeMap, string::String, vec::Vec};
use memory_addr::VirtAddr;

struct UserStack {
    sp: usize,
}

impl UserStack {
    pub fn new(sp: usize) -> Self {
        Self { sp }
    }
    fn push(&mut self, src: &[u8], stack_data: &mut Vec<u8>) {
        self.sp -= src.len();
        // let mut target_data = src.to_vec();
        // target_data.append(stack_data);
        // *stack_data = target_data;
        stack_data.splice(0..0, src.iter().cloned());
    }
    pub fn push_usize_slice(&mut self, src: &[usize], stack_data: &mut Vec<u8>) {
        for val in src.iter().rev() {
            let bytes = val.to_le_bytes();
            self.push(&bytes, stack_data);
        }
    }
    pub fn push_str(&mut self, str: &str, stack_data: &mut Vec<u8>) -> usize {
        self.push(&['\0' as u8], stack_data);

        self.push(str.as_bytes(), stack_data);
        self.sp
    }
    pub fn get_sp(&self) -> usize {
        self.sp
    }
}

fn init_stack(
    args: &[String],
    envs: &[String],
    auxv: &BTreeMap<u8, usize>,
    sp: usize,
) -> (UserStack, Vec<u8>) {
    let mut data = Vec::new();
    let mut stack = UserStack::new(sp);
    // define a random string with 16 bytes
    stack.push("0123456789abcdef".as_bytes(), &mut data);
    let random_str_pos = stack.get_sp();
    // Push arguments and environment variables
    let envs_slice: Vec<_> = envs
        .iter()
        .map(|env| stack.push_str(env, &mut data))
        .collect();
    let argv_slice: Vec<_> = args
        .iter()
        .map(|arg| stack.push_str(arg, &mut data))
        .collect();
    let padding_null = "\0".repeat(8);
    stack.push(padding_null.as_bytes(), &mut data);

    stack.push("\0".repeat(stack.get_sp() % 16).as_bytes(), &mut data);
    assert!(stack.get_sp() % 16 == 0);
    // Push auxiliary vectors
    for (key, value) in auxv.iter() {
        if (*key) == 25 {
            // AT RANDOM
            stack.push_usize_slice(&[*key as usize, random_str_pos], &mut data);
        } else {
            stack.push_usize_slice(&[*key as usize, *value], &mut data);
        };
    }

    // Push the argv and envp pointers
    stack.push(padding_null.as_bytes(), &mut data);
    stack.push_usize_slice(envs_slice.as_slice(), &mut data);
    stack.push(padding_null.as_bytes(), &mut data);
    stack.push_usize_slice(argv_slice.as_slice(), &mut data);
    // Push argc
    stack.push_usize_slice(&[args.len()], &mut data);
    (stack, data)
}

/// To get the stack pointer and initialization content for the user stack
///
/// # Arguments
///
/// * `args` - The arguments of the application
/// * `envs` - The environment variables of the application
/// * `auxv` - The auxiliary vectors of the application. It can be generated by [`crate::auxv::get_auxv_vector`], whose type is `BTreeMap<u8, usize>`.
/// The key is the entry type, and the value is the value of the auxiliary vector.
/// * `stack_bottom` - The lowest address of the user stack
/// * `stack_size` - The size of the stack.
///
/// # Return
///
/// `(expanded_content, stack_pointer)`
///
/// * `expanded_content`: Additional information on the stack, including arguments, environment variables, and auxiliary vectors.
///
/// * `stack_pointer`: The stack pointer of the application after the stack is initialized.
///
/// The detailed format is described in <https://articles.manugarg.com/aboutelfauxiliaryvectors.html>
pub fn get_app_stack_region(
    args: &[String],
    envs: &[String],
    auxv: &BTreeMap<u8, usize>,
    stack_base: VirtAddr,
    stack_size: usize,
) -> (Vec<u8>, usize) {
    let ustack_bottom = stack_base;
    let ustack_top = ustack_bottom + stack_size;
    // The stack variable is actually the information carried by the stack
    let (stack, data) = init_stack(args, envs, auxv, ustack_top.into());
    (data, stack.get_sp())
}
